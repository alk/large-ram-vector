Simple experiment to test one approach of dealing with large vectors
reallocation performance. This code uses large mmap to avoid physically
copying any pages on vector growth. It also does very agressive reuse
of used pages from unused virtual memory chunks (by decommitting
unused pages before growing memory usage elsewhere).

replay-reallocs program contains one particular sequence of vector
reallocations that is interesting to study. We're able to replay it
with this approach (arguably still in need of some tuning), regular
malloc and tcmalloc_minimal from gperftools.

On my machine I get those timings:

----
root@@big:~/tmp/large-ram-vector# bazel build -c opt :all
Starting local Bazel server (9.0.0) and connecting to it...
INFO: Analyzed 5 targets (91 packages loaded, 1076 targets configured).
INFO: Found 5 targets...
INFO: Elapsed time: 9.031s, Critical Path: 5.09s
INFO: 73 processes: 20 internal, 53 linux-sandbox.
INFO: Build completed successfully, 73 total actions
user@big:~/src/large-ram-vector# ./bazel-bin/replay-reallocs
done.
MaxRSS: 6246076
Minor faults: 39130591
Major faults: 0
CPU time: 25.2085 sec
user@big:~/src/large-ram-vector# ./bazel-bin/replay-reallocs-malloc
done.
MaxRSS: 6269096
Minor faults: 64750496
Major faults: 0
CPU time: 39.2975 sec
user@big:~/src/large-ram-vector# LD_PRELOAD=/usr/lib/x86_64-linux-gnu/libjemalloc.so ./bazel-bin/replay-reallocs-malloc
done.
MaxRSS: 6268768
Minor faults: 64750501
Major faults: 0
CPU time: 44.0282 sec
user@big:~/src/large-ram-vector# LD_PRELOAD=/usr/lib/x86_64-linux-gnu/libmimalloc.so.3.1 ./bazel-bin/replay-reallocs-malloc
done.
MaxRSS: 6269820
Minor faults: 64750497
Major faults: 0
CPU time: 42.4995 sec
user@big:~/src/large-ram-vector# ./bazel-bin/replay-reallocs-tcmalloc
done.
MaxRSS: 9261936
Minor faults: 5476307
Major faults: 0
CPU time: 13.7758 sec
user@big:~/src/large-ram-vector# ./bazel-bin/replay-reallocs-abseil-tcmalloc
done.
MaxRSS: 9652380
Minor faults: 6367528
Major faults: 3
CPU time: 14.262 sec
----
